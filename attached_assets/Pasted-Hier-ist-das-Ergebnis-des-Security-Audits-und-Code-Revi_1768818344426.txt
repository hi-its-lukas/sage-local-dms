Hier ist das Ergebnis des Security Audits und Code Reviews für das Projekt **Sage Local DMS**.

### Executive Summary

**Gesamtbewertung: Mäßig bis Kritisch**

Das Projekt zeigt solide Ansätze im Bereich Sicherheit (Einsatz von `django-mfa3`, Verschlüsselung von Inhalten mittels Fernet, Audit-Logs, rollenbasierte Zugriffskontrolle). Es ist erkennbar, dass Sicherheit bereits in der Designphase berücksichtigt wurde.

Es existieren jedoch **kritische Architekturschwächen** und **Implementierungsfehler**, die das System anfällig für Angriffe machen:

1. **Server-Side Request Forgery (SSRF) / Local File Inclusion (LFI):** Die E-Mail-zu-PDF-Konvertierung ist hochgradig unsicher und erlaubt Angreifern potenziell das Auslesen lokaler Dateien oder den Zugriff auf interne Netzwerke.
2. **Denial of Service (DoS):** Die Implementierung der Verschlüsselung und des Datei-Uploads lädt vollständige Dateien in den Arbeitsspeicher. Fernet unterstützt kein Streaming. Große Dateien führen unweigerlich zum Absturz der Anwendung (OOM Kill).
3. **Fehlkonfiguration in Production-Settings:** Die Standardwerte in `settings.py` sind für den Produktivbetrieb unsicher (Host Header Injection, Default Secrets).

---

### Detaillierte Befunde

| Schweregrad | Art | Ort | Beschreibung |
| --- | --- | --- | --- |
| **Kritisch** | **SSRF / LFI / XSS** | `dms/tasks.py` (Zeile 928-943) | In `process_email_message` wird der `message.body` ungefiltert in einen f-String eingefügt und an `pdfkit.from_string` übergeben. `pdfkit` nutzt `wkhtmltopdf` (basierend auf Qt WebKit). Ein Angreifer kann eine E-Mail mit `<iframe src="file:///etc/passwd">` oder `<script>...` senden. Der Server rendert dies und speichert sensible Systemdateien im PDF. |
| **Kritisch** | **DoS (Memory Exhaustion)** | `dms/encryption.py` (Zeile 64-83) | Die Funktion `encrypt_file_streaming` ist irreführend benannt. Sie liest zwar in Chunks, fügt diese aber mit `b''.join(chunks)` im RAM zusammen, bevor `encrypt_data` aufgerufen wird. Da Fernet (CBC/HMAC) padding-basiert ist und nicht streamt, muss die *gesamte* Datei plus Overhead (~33% Base64) im RAM liegen. Bei mehreren gleichzeitigen Uploads stürzt der Server ab. |
| **Hoch** | **Security Misconfiguration** | `dms_project/settings.py` (Zeile 7, 11) | `ALLOWED_HOSTS` fällt auf `['*']` zurück. Dies ermöglicht Host-Header-Injections (z.B. Poisoning von Password-Reset-Links). `SECRET_KEY` hat einen Default-Wert. Wenn die Env-Var vergessen wird, ist die Session-Security kompromittiert. |
| **Hoch** | **Privilege Escalation Risk** | `dms/views.py` (Zeile 70-80) | Die Methoden `sage_sync_*` prüfen nur auf `dms.change_systemsettings`. Es fehlt eine explizite Prüfung, ob der User auch Admin des *spezifischen* Mandanten ist, falls System-Admins nicht automatisch alles sehen sollen (Multitenancy-Leakage Gefahr). |
| **Mittel** | **Race Condition** | `dms/models.py` (Zeile 335) | Das Singleton-Pattern für `SystemSettings` (`pk=1`) ist nicht atomar. Bei gleichzeitigen Zugriffen könnten Einstellungen überschrieben werden. Hier sollte `select_for_update` oder ein File-Lock genutzt werden. |
| **Mittel** | **Unrestricted File Upload** | `dms/views.py` (Zeile 187) | Es wird zwar die Dateiendung geprüft (`allowed_extensions`), aber nicht der tatsächliche Dateiinhalt (Magic Bytes) *konsequent* validiert (nur via `magic` für MIME-Type, aber kein Reject bei Mismatch). Zudem fehlt ein Virenscan (ClamAV) für Dateien, die später von Usern heruntergeladen werden. |
| **Niedrig** | **Information Disclosure** | `dms/encryption.py` (Zeile 13) | Die Exception Message gibt Anweisungen zur Key-Generierung, was in Logs okay ist, aber in Stacktraces, die User sehen, unnötige Interna preisgibt. |
| **Niedrig** | **Code Smell** | `dms/tasks.py` | Die Datei ist monolithisch ("God Object") und mischt Redis-Locking, Business-Logik, PDF-Parsing und E-Mail-Handling. Schwer wartbar und testbar. |

---

### Remediation (Lösungsvorschläge)

#### 1. Behebung der kritischen SSRF-Lücke (E-Mail zu PDF)

**Problem:** Ungefilterter HTML-Input in PDF-Generator.
**Lösung:** HTML-Sanitization verwenden oder (besser) Text-Only konvertieren, wenn HTML nicht zwingend nötig ist. Für HTML muss `bleach` oder `lxml` zum Bereinigen genutzt werden, und `wkhtmltopdf` muss so konfiguriert werden, dass lokaler Dateizugriff verboten ist.

```python
# In dms/tasks.py

# 1. Import hinzufügen
import bleach
from django.utils.html import escape

def process_email_message(message, config):
    # ... (vorheriger Code) ...
    
    # SECURITY FIX: Input Sanitization
    # Erlaube nur sichere Tags, entferne iframes, scripte, styles, remote images etc.
    allowed_tags = ['b', 'i', 'u', 'p', 'br', 'strong', 'em', 'h1', 'h2', 'h3', 'ul', 'li']
    clean_body = bleach.clean(
        message.body or '', 
        tags=allowed_tags, 
        strip=True
    )
    
    # Alternativ: Behandle Body als reinen Text und escape HTML Entities
    # clean_body = escape(message.body or '')

    # SECURITY FIX: wkhtmltopdf Optionen härten
    options = {
        'disable-local-file-access': None,  # Verhindert LFI (/etc/passwd)
        'disable-javascript': None,         # Verhindert XSS
        'enable-external-links': False,
        'quiet': ''
    }

    html_content = f"""
    <html>
    <head><style>body {{ font-family: Arial, sans-serif; }}</style></head>
    <body>
    <h2>{escape(message.subject)}</h2>
    <p><strong>From:</strong> {escape(message.sender.address)}</p>
    <p><strong>Date:</strong> {escape(str(message.received))}</p>
    <hr>
    {clean_body}
    </body>
    </html>
    """
    
    try:
        pdf_content = pdfkit.from_string(html_content, False, options=options)
        # ... (Rest des Codes) ...

```

#### 2. Architektur-Fix: Streaming Encryption (Memory DoS)

**Problem:** `Fernet` lädt alles in den RAM.
**Lösung:** Umzug auf `cryptography.hazmat` primitives (AES-GCM oder ChaCha20-Poly1305) für echtes Streaming. Da dies ein größerer Eingriff ist, zeige ich hier, wie man zumindest die "Fake Streaming" Funktion in `encryption.py` ehrlich macht und das Limit durchsetzt.

*Langfristig:* Wechsele auf eine Library wie `miscreant` oder implementiere AES-GCM chunking manuell.
*Kurzfristig:* Implementiere eine strikte Größenbeschränkung VOR der Verschlüsselung.

```python
# In dms/encryption.py

def encrypt_file_streaming(file_path, chunk_size=1048576):
    """
    ACHTUNG: Fernet unterstützt kein echtes Streaming. 
    Die Datei wird komplett in den Speicher geladen.
    Diese Funktion prüft nun zumindest Limits.
    """
    file_stats = os.stat(file_path)
    # Limit auf z.B. 100MB setzen, um Server-Crash zu verhindern
    MAX_SIZE = 100 * 1024 * 1024 
    
    if file_stats.st_size > MAX_SIZE:
        raise ValueError(f"Datei zu groß für Verschlüsselung ({file_stats.st_size} bytes). Max: {MAX_SIZE}")

    # Der ursprüngliche Code war ineffizient (Chunks lesen -> Liste -> Join).
    # Besser: Alles auf einmal lesen, da es eh im RAM landet.
    with open(file_path, 'rb') as f:
        data = f.read()
    
    sha256_hash = hashlib.sha256(data).hexdigest()
    encrypted = encrypt_data(data) # encrypt_data nutzt Fernet
    
    return encrypted, sha256_hash, len(data)

```

#### 3. Härtung der Settings

**Problem:** Unsichere Defaults.
**Lösung:** Fail-Secure Ansatz. Die Anwendung sollte nicht starten, wenn kritische Sicherheitsvariablen fehlen.

```python
# In dms_project/settings.py

import os
from django.core.exceptions import ImproperlyConfigured

def get_env_variable(var_name, default=None):
    try:
        return os.environ[var_name]
    except KeyError:
        if default is not None:
            return default
        error_msg = f"Set the {var_name} environment variable"
        raise ImproperlyConfigured(error_msg)

# SECURITY FIX: Kein Default Key im Code!
SECRET_KEY = get_env_variable('DJANGO_SECRET_KEY')

# SECURITY FIX: Explizite Hosts erforderlich
ALLOWED_HOSTS = get_env_variable('ALLOWED_HOSTS').split(',')

# SECURITY FIX: SSL/HTTPS erzwingen (für Production)
if not DEBUG:
    SECURE_SSL_REDIRECT = True
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_HSTS_SECONDS = 31536000
    SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    SECURE_HSTS_PRELOAD = True

```

### Zusammenfassender Rat (Senior Architect)

"Der Code ist funktional und sauber strukturiert, aber die Verschlüsselungsarchitektur mit `Fernet` für Dokumente (BinaryField) ist eine Sackgasse. In einem DMS werden Dokumente schnell größer als der verfügbare RAM. Du musst die Datenbank von der Speicherung der Blobs entlasten (nutze `FileField` mit einem Custom Storage Backend, das 'On-the-fly' verschlüsselt und auf S3/Disk streamt) oder auf echte Stream-Ciphers wechseln. Das aktuelle Design skaliert nicht."